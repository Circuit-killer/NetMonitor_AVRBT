/* * Project: Bluetooth Net Monitor * Author: Zak Kemble, contact@zakkemble.co.uk * Copyright: (C) 2013 by Zak Kemble * License: GNU GPL v3 (see License.txt) * Web: http://blog.zakkemble.co.uk/bluetooth-net-monitor-v2/ */#include "common.h"static void processData(s_memoryChunk*);static bool manualRates;	// Are sync rates set manually in the config?static s_updateData* uptData;void modem_init(){	char* down = NULL;	char* up = NULL;	config_val("syncdown", &down);	config_val("syncup", &up);	if(strlen(down) > 0 && strlen(up) > 0)	{		manualRates = true;		uptData = calloc(1, sizeof(s_updateData));		uptData->data = calloc(1, sizeof(s_netUpDown));		ulong num;		num = strtoul(down, NULL, 10);		((s_netUpDown*)uptData->data)->down = num;		num = strtoul(up, NULL, 10);		((s_netUpDown*)uptData->data)->up = num;	}	else	{		manualRates = false;		updater_construct(			&uptData,			"adslpage",			"adsluser",			"adslpass",			"adslregex",			"adslcachetime",			&processData,			sizeof(s_netUpDown)			);	}		free(down);	free(up);}void modem_update(){	if(!manualRates)		updater_run(uptData);}s_netUpDown modem_get(){	return *(s_netUpDown*)uptData->data;}void modem_end(){	if(!manualRates)		updater_destroy(&uptData);	else	{		if(uptData->data)			free(uptData->data);		free(uptData);	}}static void processData(s_memoryChunk* chunk){	regmatch_t matches[3];	// Perform regex on data	int regexRes = regexec(&uptData->reg, chunk->memory, 3, matches, 0);	if(regexRes == 0) // Everything went OK	{		((s_netUpDown*)uptData->data)->down = updater_getMatchNum(&matches[1], chunk);		((s_netUpDown*)uptData->data)->up = updater_getMatchNum(&matches[2], chunk);	}}